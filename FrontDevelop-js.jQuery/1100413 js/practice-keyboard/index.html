<!DOCTYPE html>
<html lang="zh-tw">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>keyboard</title>

  <!-- google font -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Pangolin&display=swap" rel="stylesheet">

  <!-- PaperCSS - the less formal CSS framework -->
  <!-- https://www.getpapercss.com/ -->
  <!-- <link rel="stylesheet" href="https://unpkg.com/papercss@1.8.2/dist/paper.min.css"> -->

</head>
<style>
  body {
    padding: 1.5rem 0.5rem;
    /* overflow: scroll; */
    background-image: url('./images/watercolor.jpg');
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
  }

  .inline {
    display: inline-block;
  }

  .info {
    width: 275px;
    /* background-color: orange; */
    /* text-align: center; */
    vertical-align: top;
    box-sizing: border-box;
    padding: 51px 19px;
  }

  .game {
    /* width: calc(96% - 265px); */
    /* background-color: rgb(234, 255, 239); */
    box-sizing: border-box;
    padding: 59px 39px;
  }

  .center {
    text-align: center;
  }

  button {
    background-color: white;
    color: #350452;
    padding: 0.5rem 1rem;
    margin: 1rem;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    transition: all 235ms ease-in-out 0s;
    backdrop-filter: blur(3.5px);
    -webkit-backdrop-filter: blur(3.5px);

    /* border-radius: 5px; */
    /* border: 1px solid rgba(255, 255, 255, 0.18); */
  }

  /* 神奇不規則線條 PaperCSS framework */
  .paper-border {
    border-color: #e3b3ff8c;
    border-style: solid;
    border-width: 2px;
    border-bottom-left-radius: 15px 255px;
    border-bottom-right-radius: 225px 15px;
    border-top-left-radius: 255px 15px;
    border-top-right-radius: 15px 225px;
  }

  button:hover {
    background-color: rgb(245, 239, 255);
    box-shadow: 0 5px 15px 0 rgba(31, 38, 135, 0.37);
  }

  .game table {
    margin: auto;
    font-family: 'Pangolin', cursive;
    font-size: 2.7rem;
    box-sizing: border-box;

    /* 按鍵間距 */
    /* border-spacing: 17px; */
    border-spacing: 20px 7px;
    border-collapse: separate;

    /* 不能被選取 */
    user-select: none;
    -webkit-user-drag: none;
  }

  .game table td {
    display: inline-block;
    width: 90px;
    height: 90px;
    line-height: 90px;
    text-align: center;
    margin: 0 7px;
  }

  table#list-score {
    border: solid 1px rgb(236, 255, 61);
    padding: 8px;
  }

  table#list-score td,
  th {
    text-align: center;
    width: 45px;
  }

  table#list-score td:nth-child(2),
  th:nth-child(2) {
    width: 50px;
  }

  /* 按鍵樣式效果 https://codepen.io/veronicadev/pen/GyGLyN */
  .key {
    text-decoration: none;
    /* color: #000; */
    /* margin: auto; */
    /* width: 150px; */
    /* display: inline-block; */
    /* line-height: 40px; */
    /* font-size: 12px; */
    /* font-weight: 900; */
    /* letter-spacing: 2px; */
    text-transform: uppercase;
    background-color: rgb(247, 255, 241);
    border: 3px solid #193520;
    border-radius: 5px;
    box-shadow:
      1px 1px 0 #193520a2,
      2px 2px 0 #193520a2,
      3px 3px 0 #193520a2,
      4px 4px 0 #193520a2,
      5px 5px 0 #193520a2;
    position: relative;

    /* transition: 0.5s; */
    /* 加了後，按按鍵的效果會變很怪 */
  }

  .key:hover {
    background-color: #a4fbb248;
  }

  .key:active {
    top: 5px;
    left: 5px;
    box-shadow: 0 0 0 0;
  }

  .colorOrign {
    background-color: rgba(111, 216, 50, 0.555);
    color: rgb(119, 133, 81);
  }

  .colorOn {
    background-color: #f6d61e2d;
    color: #744802;

    /* 樣式同 .key:active */
    top: 5px;
    left: 5px;
    box-shadow: 0 0 0 0;
    /* 有被其他屬性蓋過去 */
  }

  .colorError {
    background-color: #f61e1e7e;
  }

  /* .key:after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%;
    z-index: -1;
    background-color: #fff;
    -webkit-transition: all 0.5s;
    -moz-transition: all 0.5s;
    -ms-transition: all 0.5s;
    -o-transition: all 0.5s;
  }

  .key:hover:after {
    background-color: #f6d51e;
  } */
</style>

<body>
  <div class="">
    <!-- 觸發按鈕 -->
    <div class="center">
      <button class="paper-border mode" id="start">開始</button>
      <!-- <button class="paper-border" id="stop">暫停</button> -->
      <button class="paper-border" id="end">結束</button>
      <button class="paper-border" id="switch">中英切換</button>
      <!-- <br> -->
      <button class="paper-border mode" id="key-four">隨機 <b>4鍵</b> 模式</button>
      <button class="paper-border mode" id="key-eight">隨機 <b>8鍵</b> 模式</button>
      <button class="paper-border mode" id="key-twelve">隨機 <b>12鍵</b> 模式</button>
      <button class="paper-border mode" id="key-random">
        隨機 <b>隨機鍵</b> 模式
        <br><small>本次隨機到<span id="key-R"> - </span>鍵</small>
      </button>
    </div>


    <!-- 遊戲區 -->
    <div class="game inline">
      <table>
        <tr>
          <td id="Digit1" class="key">1</td>
          <td id="Digit2" class="key">2</td>
          <td id="Digit3" class="key">3</td>
          <td id="Digit4" class="key">4</td>
          <td id="Digit5" class="key">5</td>
          <td id="Digit6" class="key">6</td>
          <td id="Digit7" class="key">7</td>
          <td id="Digit8" class="key">8</td>
          <td id="Digit9" class="key">9</td>
          <td id="Digit0" class="key">0</td>
          <td></td>
        </tr>
      </table>
      <table>
        <tr>
          <td id="KeyQ" class="key">Q</td>
          <td id="KeyW" class="key">W</td>
          <td id="KeyE" class="key">E</td>
          <td id="KeyR" class="key">R</td>
          <td id="KeyT" class="key">T</td>
          <td id="KeyY" class="key">Y</td>
          <td id="KeyU" class="key">U</td>
          <td id="KeyI" class="key">I</td>
          <td id="KeyO" class="key">O</td>
          <td id="KeyP" class="key">P</td>
        </tr>
      </table>
      <table>
        <tr>
          <td id="KeyA" class="key">A</td>
          <td id="KeyS" class="key">S</td>
          <td id="KeyD" class="key">D</td>
          <td id="KeyF" class="key">F</td>
          <td id="KeyG" class="key">G</td>
          <td id="KeyH" class="key">H</td>
          <td id="KeyJ" class="key">J</td>
          <td id="KeyK" class="key">K</td>
          <td id="KeyL" class="key">L</td>
        </tr>
      </table>
      <table>
        <tr>
          <td id="KeyZ" class="key">Z</td>
          <td id="KeyX" class="key">X</td>
          <td id="KeyC" class="key">C</td>
          <td id="KeyV" class="key">V</td>
          <td id="KeyB" class="key">B</td>
          <td id="KeyN" class="key">N</td>
          <td id="KeyM" class="key">M</td>
          <td></td>
        </tr>
      </table>
    </div>


    <!-- 資訊區 -->
    <div class="info inline">
      <p>Key(目前點擊)：<span id="key-score"> - </span>鍵</p>
      <p>Error(目前點擊)：<span id="error-score"> - </span>鍵</p>
      <p>Time(持續時間)：<span id="time-score"> - </span>秒</p>
      <p>Player(遊戲紀錄)：<span id="player-score"> - </span>
        <!-- <ul id="list-score">
        <li>等級 - 姓名 - 鍵數 - 時間</li>
      </ul> -->
      <table id="list-score">
        <tr>
          <th>等級</th>
          <th>姓名</th>
          <th>按到鍵數</th>
          <th>錯誤鍵數</th>
          <th>時間</th>
        </tr>
      </table>
      </p>
    </div>
  </div>

  <!-- sweetalert2  js-->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@10"></script>

  <script>

    const btn = document.getElementsByTagName('button')
    const btnStart = document.getElementById('start')
    const btnStop = document.getElementById('stop')
    const btnEnd = document.getElementById('end')
    const tds = document.getElementsByTagName('td')
    // console.log(tds);
    const modes = document.getElementsByClassName('mode')
    // console.log(modes);

    const keyFour = document.getElementById('key-four')
    const keyEight = document.getElementById('key-eight')
    const keyTwelve = document.getElementById('key-twelve')
    const keyRandom = document.getElementById('key-random')
    const keyR = document.getElementById('key-R')

    const Switch = document.getElementById('switch')

    const KeyScore = document.getElementById('key-score')
    const ErrorScore = document.getElementById('error-score')
    const TimeScore = document.getElementById('time-score')
    const PlayerScore = document.getElementById('player-score')
    const ListScore = document.getElementById('list-score')

    let key = 0     //按到的鍵數
    let error = 0   //按錯的鍵數
    let time = 0    //持續的時間

    // 將要存入 Storage 的資料命名成變數 ScoreHistory (JSON 物件) 包起來
    let ScoreHistory = { level: '', name: '', key: 0, error: 0, time: 0 }

    // 問號運算子 - 條件 ? 成立時執行的程式  : 否定時執行的程式
    // 宣告一個容器為陣列，StorageArr 代表儲存多筆資料，先判斷瀏覽器是否存在資料，若無我們就初始化並新增一個容器，反之若有則使用 getItem() 方法將值從瀏覽器中撈出來。
    // 將資料 Storage 取出         JSON.parse()：JSON 變物件
    const ScoreStorage = (localStorage.getItem('Keyboard-Play')) ? JSON.parse(localStorage.getItem('Keyboard-Play')) : { StorageArr: [] };

    // 將值新增進 html 裡
    //   KeyScore.innerText = ScoreHistory.key
    //   ErrorScore.innerText = ScoreHistory.error
    //   TimeScore.innerText = ScoreHistory.time


    // 假如資料庫內有內容，將內容加到 ListScore
    for (let S in ScoreStorage.StorageArr) {
      if (ScoreStorage !== 0) {
        ListScore.insertAdjacentHTML('beforeend', `
        <tr>
          <td align="center">${ScoreStorage.StorageArr[S].level}</td>
          <td align="center">${ScoreStorage.StorageArr[S].name}</td>
          <td align="center">${ScoreStorage.StorageArr[S].key}鍵</td>
          <td align="center">${ScoreStorage.StorageArr[S].error}鍵</td>
          <td align="center">${ScoreStorage.StorageArr[S].time}秒</td>
        </tr>
        `)
      }
    }


    // 計算用 function
    const calc = () => {

      key = 0
      KeyScore.innerText = key

      time = 0
      TimeScore.innerText = time
    }

    //遊戲開始後所有模式不能點擊 function
    const modeDisabled = (D) => {
      for (const mode of modes) {
        mode.disabled = D
      }
    }
    // console.log(modes); //5  

    // 製作隨機按鍵的 function
    const keyValue = (k) => {
      for (const td of tds) {
        td.classList.remove('colorOrign')
        td.classList.remove('colorOn')
        td.classList.remove('colorError')
      }

      for (let i = 0; i < k; i++) {
        const random = Math.floor(Math.random() * 38)

        // 判斷隨機數字如果為 tds[10]或[38] 則跳過
        if (random === 10) {
          i--
          console.log(10);
        } else if (random === 37) {
          i--
          console.log(37);
        } else {
          tds[random].classList.add('colorOrign')
        }

        // 判斷不能有重複的隨機數字
        // while (tds.includes(random)) {
        //   i--
        // }
      }
      //因為現在預設計時器為 1秒更新，所以 time++可以寫在這裡，如果預設不是1秒要另外寫
      time++
      TimeScore.innerText = time
    }

    // 判斷獲得等級
    const level = () => {
      // 設變數-總出現鍵數；計算 key/總出現鍵數的%  /  error/總出現鍵數的%

      if (key < 5) {
        return '鐵人'
        //    ${key} 鍵，鐵人
      } else if (key >= 5 && key < 10) {
        return '青銅'
        //    ${key} 鍵，青銅
      } else if (key >= 10 && key < 15) {
        return '白銀'
        //    ${key} 鍵，白銀
      } else if (key >= 15 && key < 20) {
        return '黃金'
        //    ${key} 鍵，黃金
      } else {
        return '鑽石'
        //    ${key} 鍵，鑽石
      }
      // 鑽石 黃金 白銀 青銅 鐵人
    }

    // 開始 按鍵
    btnStart.onclick = () => {
      modeDisabled(true)
      calc()

      // timer = setInterval(keyValue, 3000, 2)
      setInterval(keyValue, 3000, 2)
      keyValue(2)  //初始二鍵模式
    }

    // 暫停 按鍵 --好像可以不需要...或再增加繼續按鈕?
    // btnStop.onclick = () => {
    //   console.log('stop');
    //   clearInterval(timer)
    // }

    // 結束 按鍵
    btnEnd.onclick = () => {
      console.log('end');
      clearInterval(keyValue)
      modeDisabled(false)

      for (const td of tds) {
        td.classList.remove('colorOrign')
        td.classList.remove('colorOn')
      }

      Swal.fire({
        title: `恭喜你成功按到 ${key} 個鍵，加油
                <br>目前等級為 ${level()}
                <br>路過請留下大名，謝謝`,
        input: 'text',
        inputAttributes: {
          maxlength: 3, //控制字數
          //   autocapitalize: 'off'
        },
        // showCancelButton: true,
        confirmButtonText: 'OK',
        // showLoaderOnConfirm: true,
        allowOutsideClick: () => !Swal.isLoading()
      }).then((result) => {
        // console.log(result.value);
        ListScore.insertAdjacentHTML('beforeend', `
        <tr>
          <td align="center">${level()}</td>
          <td align="center">${result.value}</td>
          <td align="center">${key}鍵</td>
          <td align="center">${error}鍵</td>
          <td align="center">${time}秒</td>
        </tr>
        `);

        ScoreHistory.level = level()
        ScoreHistory.key = key
        ScoreHistory.error = error
        ScoreHistory.time = time
        ScoreHistory.name = result.value

        KeyScore.innerText = ScoreHistory.key
        ErrorScore.innerText = ScoreHistory.error
        TimeScore.innerText = ScoreHistory.time

        // 把 ScoreHistory 放進 ScoreStorage 裡，會是陣列型態
        ScoreStorage.StorageArr.push(ScoreHistory)

        // 將資料存入 Storage                            JSON.stringify() 將物件變 JSON
        localStorage.setItem('Keyboard-Play', (JSON.stringify(ScoreStorage)))
        // console.log(StorageArr);
        // console.log(ScoreHistory);

        // 每次結束後，都重新整理，讓 ScoreHistory 可以重新儲存新的變數
        window.location.reload();
      })
    }

    keyFour.onclick = () => {
      modeDisabled(true)
      calc()

      setInterval(keyValue, 3000, 4)
      keyValue(4)
    }

    keyEight.onclick = () => {
      modeDisabled(true)
      calc()

      setInterval(keyValue, 3000, 8)
      keyValue(8)
    }

    keyTwelve.onclick = () => {
      modeDisabled(true)
      calc()

      setInterval(keyValue, 3000, 12)
      keyValue(12)
    }

    keyRandom.onclick = () => {
      modeDisabled(true)
      calc()

      let R = Math.floor(Math.random() * 38)
      console.log(`${R}`);
      keyR.innerText = R

      setInterval(keyValue, 3000, R)
      keyValue(R)
    }


    // 每個 td 的滑鼠點擊事件 --這個遊戲不需要
    // for (const td of tds) {
    //   td.onclick = () => {
    //     if (td.classList.contains('colorOrign')) {
    //       td.classList.replace('colorOrign', 'colorOn')

    //       key++
    //       KeyScore.innerText = key

    //       time++
    //       TimeScore.innerText = time
    //     }
    //   }
    // }

    // 每個 td 的按鍵事件 --偵測按到哪個鍵
    document.onkeydown = (event) => {
      if (event.code.includes('Key') || event.code.includes('Digit')) {
        // 按到的那個鍵
        const type = document.getElementById(`${event.code}`)
        console.log(window.event.code);

        if (type !== null && type.classList.contains('colorOrign')) {
          // 如果按到的鍵是正確的鍵，會加分
          type.classList.replace('colorOrign', 'colorOn')
          key++
          KeyScore.innerText = key
        } else {
          // 如果按到錯誤的鍵，錯誤鍵數會增加，並且改色
          type.classList.add('colorError')
          // type.classList.replace('colorOrign', 'colorError')
          // type.setAttribute("background-color", "#f61e1e")
          error++
          ErrorScore.innerText = error
        }
      }
    }


    //要如何呼叫 td ? 只能去每個單獨命名ID嗎? 或是可以用陣列呼叫? --只能單獨命名ID

    // key 值會奇怪的增加 --0415解決
    // 最後 alert 的 key 值與頁面顯示的不同 --0415解決
    // 若要套用 PaperCSS framework 如何讓他只作用在 button ，看不太懂他的 css --0419解決
    // 結束按鈕失靈...  --0416解決
    // 若一直按結束，隨機到M時，會按鍵+1(神奇)  -0416就沒了
    // 判斷按鍵隨機時不重複，且不要隨機到空白那格 -0424就沒了，0427還是有，0429修好
    // 設定所有有 .mode 的按鈕開始後不能被點選，可以選到，但是沒有作用 --0427解決
    // 成績不能一筆一筆一直存嗎? --0429解決
    // 按鍵效果css 要有按鍵被壓扁的感覺 (.key:active 有效)(.colorOn 沒效)  --0428解決，原來是因為權重及先後順序問題
    // 按結束遊戲不會停止 --OK

    // 計算總出現的鍵，設變數 ++，並計算錯誤率及正確率
    // 判斷不能有重複的隨機數字
    // 按結束按鈕，到輸入名字完成時，這段時間按鍵還是會繼續跑
    // sweetalert 更改 font-size
  </script>
</body>

</html>